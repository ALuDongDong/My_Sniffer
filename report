一、程序框架和流程图
 
（1）后台抓包模块
后台抓包模块是用了一个线程，因为用运行用户界面的同时抓包传数据，所以需要一个线程进行抓包，因此Sniffer线程继承了PyQt自带的线程QThread，这个类设置了一个pyqtSingal信号，因为要与前台界面交互，因此要设置一个信号来传递解析后的数据包给前台，前台有一个接收信号的槽，用来接收数据包并对其进行处理、显示。

（2）解析数据包模块
解析数据包模块采用pcapy库，首先获取设备列表，选择设备进行嗅探，嗅探到数据包之后才能解析，嗅探到的数据包是pcapy数据包，包含pcapy包头和数据包两部分。可以从pcapy包头中解析出数据包的总长度和时间，数据包就是我们真正要解析的数据包了。然后根据以太网协议、IP协议、TCP协议、UDP协议、ICMP协议、ARP协议从各协议的包头中解析出有用的信息。最后将每个包的数据用字典格式存储，并把所有的包传到后台抓包模块用列表存储。

（3）前台界面模块
前台界面模块采用PyQt5库编写。首先写一个大的框架把基本格式写好，这里用水平布局和垂直布局写。然后把需要展示的功能通过信号&槽机制与后台的抓包模块进行交互，对传过来的数据包进行处理，再结合PyQt5中的控件，最终将结果展示出来。

（4）用户接口模块
用户接口模块就是把其他三个模块进行结合，然后调用QWitgets的QApplication控件运行即可。

二、	问题和解决方法
（1）安装pcapy包遇到的问题
一开始在Python2下能成功安装pcapy包，可是后来在Python3下就一直安装不了pcapy包，试了各种办法，安了整一天没有结果……内心是绝望又崩溃的。后来终于在一位博主的帮助下成功安装了！

（2）设置网卡时遇到的问题
想要传递QComoBox当前选项选中的字符串，于是就直接使用self.device.currentIndexChanged()方法，它能根据选中的项使索引发生变化。connect()调用currentText()方法得到当前选项的字符串。但是发现connect()没有返回值…..也就是说无法得到。后来想到在connect()连接的这个方法内部调用sniffer.Sniffer()就能直接将currentText()作为参数，直接调用线程了！但是发现后面的点击catch按钮需要用到这个sniffer，如果继续在这个函数中继续button.clicked.connect()发现程序并不能运行….只能换别的思路。查阅资料终于找到了解决方案：那就是重新定义一个信号，当点击catch按钮时就发送这个信号，这个信号的参数就是currentText()，该信号与capture_packet连接进行包的捕获。

（3）信号从后台传到前台格式不一致导致的问题
因为后台的数据是由字典组成的列表。所以想到发送的信号也应该是list格式。前台由于我还不会使用QTableWidget控件，所以先让其暂时通过QPlainTextEdit控件在前台表示出来，当然这是通过字符串的形式…于是丢包….而且每个包都丢一半….一直找不到原因还…后来终于在xx和xx的帮助下发现了这个问题…所以都转成str格式发送了。

（4）对QTableWidget和QTableView控件的使用问题
这两个控件我一直觉得差不多…..后者继承了前者。一开始我使用的是QTableView控件，然后用QStandardModel写一个模型，再调用QTableView.setModel()连接即可。但是！写这个模型时一直出问题…一直是所有的包都在每个表格中表示….还不知道问题出在哪里…因为看网上都是这样写的….后来终于在xxx同学的帮助下明白了！原来QStandardItem()是设置每个表格的意思…于是他让我用QTableWidget控件，而且让我看了他写的表格，因为我把表格的行给确定了，但我不知道怎么办，原来他是使用insertRow()方法来插入行的！而且使用setItem()对每行的每一个表格进行设置，终于问题得到了解决。

（5）对信号槽机制的理解问题
一种方法可以在sniffer中传递空信号作为收到包的触发器，然后在主线程中用self.sender()接收信号，并调用sniffer中的self.pack_list.pop(0)方法将数据包传到前台，最后再对此数据包进行操作。（此种方法可以传递任意类型的数据包）
另一种方法是在后台直接传送list类型的数据，前提是先设置好list类型的信号，然后直接传递。（易于理解但是只能传递指定类型的数据）

（6）写包列表界面时常常程序终止问题
由于后台我只解析了TCP\UDP\ICMP\ARP四个协议，所以当有其他协议时自然无法解析，于是程序意外终止，这时，只需要在前台收到packet时，对其进行判断是否为None即可，因为如果后台无法解析它会返回None

（7）	写包十六进制界面时遇到的问题
由于显示包的十六进制，因此首先要获取包解析前的数据。一开始想到的是按照在sniffer后台再构造一个列表用来存解析前的数据，但是一方面很麻烦另一方面前台没法写啊，因为这个数据需要点击表格中的数据来显示，这样存在对应问题……然后又遇到了进制转化问题，由于解析前的数据是“\x00\x01\x02”类型的bytes数据流，也就是16进制形式的数据流，直接用hex()可得到000102这样的16进制字符串，但是怎么转为unicode编码呢？因为我老想着这是16进制的字符串不是16进制的整数，所以感觉无法转化……后来查到可以通过int(s,16)先转为10进制，再chr()转为ascii即可。对于第一个问题，xx给我出了个主意：将包的原始16进制数据添加到解析后的字典后面就行。于是试了一试，果然方便多了！然后就是QTableWidget和QPlainTextEdit的对应问题。首先设置一个信号，用于发送显示hex数据的信号。在pack_receive里就发送这个信号，用itemClicked连接信号的槽，该槽就用于hex显示，结果发现点击后PlainTextEdit中hex数据一直不断的出现，也就是说一旦点击，表格和Hex数据这两个块就一直不停地出现新的数据了。他俩同步了！这不是我想要的啊~~~然后想要不对每行设置一个索引？但是行不通貌似……再后来经过反复测试终于想到设置一个变量，当点击表格中的数据时就触发显示函数，不点击时设为False即可。果然成功了！

三、收获和体会
通过本次实验我收获良多，其中最大的体会就是代码写的太少了！我决心以后尽量每天都要花两个小时写代码！本次实验是我第一次用编程语言独立写一个东西（其实在很多的同学的帮助下），虽然很简陋，但是能写完我就很开心了！（以后再对其好好修改）拿到这个题目其实我一点思路都没有，毫无编程项目经验的我一头雾水，多亏了xxx同学耐心地告诉我一步步该怎么做，而且途中遇到的很多问题都是他帮忙解决的，很感谢他！还有就是感觉自己的自学能力不是很强，解决问题能力也不强，遇到问题总感觉找不到解决方法，很奇怪！另外就是遇到难以解决的事情容易焦躁，这两点需要提高和改正！最后就是代码量真的太少了！

四、	程序界面
（1）图一：运行之前
 
（2）图二：直接抓包
 
（3）图三：过滤一下
 
